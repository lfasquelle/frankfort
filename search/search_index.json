{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ESSAID\u00e9buguer","text":"<p>Lorsqu'on apprend \u00e0 programmer, on passe un temps long \u00e0 d\u00e9buguer. C'est normal!</p> <p>Ne n\u00e9gligez jamais le temps de d\u00e9bug, ce temps est un temps important pour apprendre. C'est en cherchant \u00e0 corriger ses erreurs que l'on modifie petit \u00e0 petit sa fa\u00e7on de penser et que l'on acqui\u00e8re ainsi les bons r\u00e9flexes.</p>"},{"location":"bugs/","title":"Quelques erreurs \u00e0 conna\u00eetre","text":"<p>Lorsque vous fa\u00eetes certaines erreurs (par exemple des erreurs de syntaxe),  Python peut parfois les d\u00e9tecter et  envoie dans ce cas un message correspondant \u00e0 l'erreur.</p> <p>Note</p> <p>Parfois une erreur en engendre une autre et le message renvoy\u00e9 demande un temps de r\u00e9flexion...</p> <p>Vous devez reconna\u00eetre les erreurs les plus classiques et savoir les corriger.</p>"},{"location":"bugs/#division-by-zero","title":"division by zero","text":"<pre><code>&gt;&gt;&gt; mot = ''\n&gt;&gt;&gt; 3/len(mot)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n</code></pre> <p>Cette erreur <code>division by zero</code> est facile \u00e0 comprendre. Bien s\u00fbr, elle est rarement aussi directe que dans le  code pr\u00e9c\u00e9dent. En g\u00e9n\u00e9ral, il s'agit d'une division par une variable et cette variable a pris la valeur 0... Il faut alors rep\u00e9rer dans son code \u00e0 quel moment cette variable prend la valeur 0 et corriger...</p>"},{"location":"bugs/#is-not-callable","title":"is not callable","text":"<pre><code>&gt;&gt;&gt; mot = 'coucou'\n&gt;&gt;&gt; mot(2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object is not callable\n</code></pre> <p>L'erreur <code>is not callable</code> peut se traduire par n'est pas appelable. Une fonction peut \u00eatre  appel\u00e9e (f \u00e9tant le nom d'une fonction, un code tel que <code>f(2)</code> qui calcule f(2) effectue un appel \u00e0 la fonction) et en classe de premi\u00e8re NSI,  ce sera les seuls objets python appelables.</p> <p>Si on suppose que le codeur voulait acc\u00e8der \u00e0 l'\u00e9l\u00e9ment d'indice 2 de la cha\u00eene 'coucou',  l'erreur faite ici est d'avoir utilis\u00e9  des parenth\u00e8ses au lieu de crochets, c'est \u00e0 dire d'avoir  \u00e9crit <code>mot(2)</code> au lieu de <code>mot[2]</code>.</p>"},{"location":"bugs/#out-of-range","title":"out of range","text":"<pre><code>&gt;&gt;&gt; mot = 'coucou'\n&gt;&gt;&gt; mot[6]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: string index out of range\n</code></pre> <p><code>out of range</code> se traduit par hors de port\u00e9e ou en-dehors de la plage (ou en-dehors de la fourchette ...). Cette erreur se produit en g\u00e9n\u00e9ral  quand vous cherchez \u00e0 acc\u00e8der \u00e0 un \u00e9l\u00e9ment d'indice n'existant pas. Dans l'exemple, les indices vont de 0 \u00e0 5: il n'y a pas d'\u00e9l\u00e9ment ayant pour indice 6 dans la cha\u00eene 'coucou'.</p>"},{"location":"bugs/#indentationerror","title":"IndentationError","text":"<p>Une erreur d'indentation a lieu \u00e0 chaque fois que vous d\u00e9limitez mal vos blocs d'instructions.</p> <p>Exemple:</p> <pre><code>s = 0\np = 1\nfor i in range(10):\n    s = s + i\n      p = p*i\n</code></pre> <p>Le d\u00e9calage pour l'instruction <code>p = p*i</code>  n'a aucun \"sens\" ici...</p>"},{"location":"debug/","title":"D\u00e9buguer","text":""},{"location":"debug/#quest-ce-quun-bug","title":"Qu'est ce qu'un bug?","text":"<p>Note</p> <p>Extrait de wikipedia</p> <p>En informatique, un bug (insecte en anglais) ou bogue (au Qu\u00e9bec et en France)  est un d\u00e9faut de conception d'un programme informatique \u00e0 l'origine d'un dysfonctionnement.</p> <p>La gravit\u00e9 du dysfonctionnement peut aller de b\u00e9nigne,  causant par exemple des d\u00e9fauts d'affichage mineurs, \u00e0 majeure,  tels un crash syst\u00e8me pouvant entra\u00eener de graves accidents,  par exemple la destruction en vol de la premi\u00e8re fus\u00e9e Ariane 5, en 1996.</p> <p>Un bug peut r\u00e9sider dans une application,  dans les logiciels tiers utilis\u00e9s par cette application,  voire dans le firmware d'un composant mat\u00e9riel  comme ce fut le cas du bug de la division du Pentium. </p> <p>Un bug, c'est essentiellement un d\u00e9faut de programmation.</p> <p>En apprenant \u00e0 programmer, vous commettrez deux types de bugs:</p> <ul> <li>l'erreur de syntaxe: non respect de la syntaxe du langage, oubli d'une indentation, oubli d'un param\u00e8tre dans une fonction...  Dans ce cas, votre programme ne s'ex\u00e9cute m\u00eame pas. Toute erreur de ce type devra \u00eatre corrig\u00e9e, que ce soit durant les s\u00e9ances d'exercices ou pour un travail en-dehors du temps de classe. Pour un devoir \u00e0 rendre, la pr\u00e9sence d'une telle erreur entra\u00eene la note minimale.</li> <li>l'erreur de logique: le programme ne fait pas tout \u00e0 fait ce qui est attendu, vous avez oubli\u00e9 un ou des  cas... Il faut \u00e9galement autant que possible \u00e9liminer ce genre d'erreurs. </li> </ul>"},{"location":"debug/#corriger-un-bug-de-syntaxe","title":"Corriger un bug de syntaxe","text":"<p>Les outils pour corriger un tel bug:</p> <ul> <li>Relire le cours.</li> <li>Consulter la documentation python en ligne ou en local (fonction help...)</li> <li>Utiliser les f-strings et la fonction print pour afficher les r\u00e9sultats interm\u00e9diaires et comprendre \u00e0 quel moment une variable n'est pas du type attendu.</li> <li>On peut \u00e9galement utiliser le site python tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure du d\u00e9roulement, ce qui facilite le rep\u00e8rage de la source  du bug. </li> <li>L'affichage des \u00e9tats des variables peut aussi \u00eatre obtenu avec les bons \u00e9diteurs d\u00e9di\u00e9s  (spyder par exemple).</li> </ul>"},{"location":"debug/#corriger-un-bug-de-logique","title":"Corriger un bug de logique","text":"<ul> <li>Toujours anticiper en pr\u00e9voyant un jeu de tests de  vos fonctions, c'est \u00e0 dire des exemples de param\u00e8tres et du r\u00e9sultat qui doit \u00eatre obtenu. Penser toujours aux cas extr\u00eames: par exemple, pour une fonction concernant les cha\u00eenes de caract\u00e8res, que se passe-t-il pour la cha\u00eene vide?</li> <li>Utiliser les f-strings et la fonction print pour afficher les r\u00e9sultats interm\u00e9diaires et comprendre \u00e0 quel moment une variable n'a plus la valeur esp\u00e9r\u00e9e.</li> <li>Afficher l'\u00e9tat des variables avec les outils propos\u00e9s par un bon IDE ou pythontutor par exemple.</li> <li>\u00c9crire une fonction de tests.</li> <li>Utiliser les outils de debug d'un bon IDE (par exemple spyder).</li> </ul>"},{"location":"exercice1/","title":"Un exercice de d\u00e9bug","text":""},{"location":"exercice1/#exercice","title":"Exercice","text":"<p>Antoine doit \u00e9crire une fonction python calculant pour un entier n, le nombre \\(n! = 1\\times 2\\times 3 \\times ... \\times n\\).</p> <pre><code>def factoriel(n):\n    \"\"\"\n    n -- entier naturel &gt; 0\n\n    renvoie n!\n    &gt;&gt;&gt; 1!\n    1\n    &gt;&gt;&gt; 2!\n    2\n    &gt;&gt;&gt; 3!\n    6\n    &gt;&gt;&gt; 5!\n    120\n    \"\"\"\n</code></pre> <p>Important</p> <p>Rappelons que le docstring et un jeu de tests pr\u00e9sent\u00e9s comme ci-dessus sont toujours attendus pour vos fonctions.  </p> <p>Antoine propose le code suivant:</p> <pre><code>def factoriel(n):\n    \"\"\"\n    n -- entier naturel &gt; 0\n\n    renvoie n!\n    &gt;&gt;&gt; 1!\n    1\n    &gt;&gt;&gt; 2!\n    2\n    &gt;&gt;&gt; 3!\n    6\n    &gt;&gt;&gt; 5!\n    120\n    \"\"\"\n    f = 0\n    for i in range(n):\n        f = f*i\n    return f\n</code></pre> <ul> <li>Utiliser doctest pour savoir quels tests r\u00e9ussissent.</li> <li>Ins\u00e9rer des <code>print</code> dans ce code pour suivre l'\u00e9volution des variables et corriger ce code.</li> </ul> Rappel de la commande doctest <p>Si le script se trouve dans le fichier factoriel.py, dans la console entrez:</p> <pre><code>$ python3 -m doctest -v factoriel.py\n</code></pre> R\u00e9ponse possible <p>Affichage de messages possibles pour suivre l'\u00e9volution des valeurs des variables: fichier ipynb (version html).</p> <p>Des corrections:</p> <ul> <li>les tests doivent utilis\u00e9s le nom de la fonction!</li> <li>f ne doit pas \u00eatre initialis\u00e9 \u00e0 0 mais \u00e0 1.</li> <li>la premi\u00e8re valeur prise par i ne doit pas \u00eatre 0 mais 1.</li> </ul> <p>Enfin une derni\u00e8re erreur:</p> <ul> <li>la derni\u00e8re valeur prise par i doit \u00eatre n et non n-1.</li> </ul> <p>D'o\u00f9 une proposition de code:</p> <pre><code>def factoriel(n):\n    \"\"\"\n    n -- entier naturel &gt; 0\n\n    renvoie n!\n    &gt;&gt;&gt; factoriel(1)\n    1\n    &gt;&gt;&gt; factoriel(2)\n    2\n    &gt;&gt;&gt; factoriel(3)\n    6\n    &gt;&gt;&gt; factoriel(5)\n    120\n    \"\"\"\n    f = 1\n    for i in range(1, n+1):\n        f = f*i\n    return f\n</code></pre> <p>Test (version python &gt;= 3.6):</p> <pre><code>for i in range(6): print(f\"{i}! = {factoriel(i)}\")\n</code></pre> <p>Test avec une version python &lt; 3.6:</p> <pre><code>for i in range(6): print(\"{}! = {}\".format(i, factoriel(i)))\n</code></pre> <p>Note</p> <p>Lorsqu'on a fini de d\u00e9buguer, il ne faut pas oublier de supprimer tous les print de debugage. C'est ce qui fait qu'il est, \u00e0 terme, pr\u00e9f\u00e9rable d'\u00e9crire des fonctions de tests ind\u00e9pendantes: on \u00e9vite d'ajouter, enlever, ajouter, enlever... des lignes de print pour d\u00e9buguer. Mais les print (ou l'affichage des valeurs des variables via un outil ad\u00e9quat) restent souvent pratiques sur des petits programmes pour rep\u00e8rer \u00e0 quel endroit on a commis une erreur de conception.</p> Une utilisation de doctest sans passer par la ligne de commande <p>Copier et coller le code ci-dessous dans un \u00e9diteur (geany, spyder...). Tester (notamment en glissant des erreurs dans le code de la fonction pour visualiser la r\u00e9ponse de doctest).</p> <pre><code>def factoriel(n):\n    \"\"\"\n    n -- entier naturel &gt; 0\n\n    renvoie n!\n    &gt;&gt;&gt; factoriel(1)\n    1\n    &gt;&gt;&gt; factoriel(2)\n    2\n    &gt;&gt;&gt; factoriel(3)\n    6\n    &gt;&gt;&gt; factoriel(5)\n    120\n    \"\"\"\n    f = 1\n    for i in range(1, n+1):\n        f = f*i\n    return f\n\n# tests des fonctions pouvant \u00eatre test\u00e9es avec doctest:\nimport doctest\ndoctest.testmod()\n</code></pre>"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#tutoriel-site-web-avec-mkdocs","title":"Tutoriel site web avec mkdocs","text":""},{"location":"ressources/#environnement-numerique-de-travail","title":"Environnement Num\u00e9rique de Travail","text":"<ul> <li>GitHub avec VSC</li> <li>Les notebook jupyter</li> <li>Tutoriel pour Obsidian/</li> <li>E.N.T. ECA.M</li> </ul>"},{"location":"ressources/#autres-liens-directs","title":"Autres liens directs","text":"<ul> <li> GitHub</li> <li>Ecole Directe</li> <li>Microsoft 365</li> <li>EC@M</li> <li>CDI</li> </ul>"}]}